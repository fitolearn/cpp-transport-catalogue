# Transport catalogue

# Описание программы
Транспортный справочник поддерживает графический вывод, поиск маршрутов и вычисление времени поездки.
Сначала на вход подаются запросы на создание базы данных, затем — запросы к самой базе.

При создании базы данных командой `-make_base` результат построения **сериализуется** и сохраняется в файл, указанный в параметре `serialization_settings`.
Затем при вызове команды `-process_requests` из фала, указанного в параметре `serialization_settings` производится **десериализация** созданной базы и выполняются запросы.

При помощи запросов, можно узнать: <br>
 - какие автобусные маршруты проходят через остановку<br>
 - какие остановки есть на автобусном маршруте<br>
 - узнать кратчайший по времени маршрут между двумя остановками<br>
   На маршруте человек может использовать несколько автобусов. <br>
   Один автобус даже можно использовать несколько раз, если на некоторых участках он делает большой крюк и проще срезать на другом автобусе.<br>

# Перед тем как начать:
  1. Установка и настройкка всех требуемых компонентов в среде разработки длля запуска приложения
  2. Вариант использования показан в main.cpp и при вызове `./transport_catalogue -help`
  3. Примеры входных документов и ответы на них есть в папке `Examples`.

## Описание возможностей:
### Программа make_base
Задача программы make_base — построить базу и сериализовать её в файл с указанным именем.<br>

На вход программе make_base подаётся JSON со следующими ключами:<br>
 - base_requests: запросы Bus и Stop на создание базы.<br>
 - render_settings: настройки отрисовки.<br>
 - serialization_settings: настройки сериализации.<br>
 - routing_settings — настройки маршрутизации, словарь с двумя ключами:<br>
   bus_wait_time — время ожидания автобуса на остановке, в минутах.<br>
   bus_velocity — скорость автобуса, в км/ч. 

### Программа process_requests
Программа process_requests должна вывести JSON с ответами на запросы.<br>	
  
На вход программе process_requests подаётся файл JSON со следующими ключами:<br>
 - stat_requests: запросы Bus и Stop к готовой базе.<br>
 - serialization_settings: настройки сериализации.<br>
 - Route — это запросы на построение маршрута между двумя остановками.<br>
 	Помимо стандартных свойств id и type, они содержат ещё два:<br>
	from — остановка, где нужно начать маршрут.<br>
	to — остановка, где нужно закончить маршрут.<br>
	Оба значения — названия существующих в базе остановок. Однако они, возможно, не принадлежат ни одному автобусному маршруту.<br>

# Требования:
1. -std=c++17
2. g++ (MinG w64) 13.2.0

# Стек технологий:
  1. Хеш-функции, **unordered_map** и **unordered_set**
  2. JSON
  3. Умные указатели **unique_ptr**, **shared_ptr** и **weak_ptr**
  4. Наследование и полиморфизм, абстрактные классы, интерфейсы
  5. Runtime-полиморфизм с std::variant, динамическое приведение типов
  6. Immediately invoked lambda expression, **std::invoke**
  7. **mutable**
 8. Работа с путями и потоками: ввода/вывода, строковыми, для работы с файлами
 9. Регулярноые выражения **std::regex**
 10. RAII - "Resource Acquisition is Initialization”
 11. **move**-семантика, Forwarding reference
 12. Cериализация, десериализация, Google Protocol Buffers - Protobuf
 13. Таблица виртуальных методов

# Структура
### Описание файлов программы
 - transport_catalogue.h, transport_catalogue.cpp — класс транспортного справочника<br>
 - main.cpp — точка входа.<br>
 - graph.h — класс, реализующий взвешенный ориентированный граф<br>
 - router.h — класс, реализующий поиск кратчайшего пути во взвешенном ориентированном графе<br>
 <br>
 - domain.cpp, domain.h - В этом файле классы/структуры, которые являются частью предметной области (domain) приложения и не зависят от транспортного справочника<br>
 - geo.cpp, geo.h - функции для работы с географическими координатами<br>
 - json.cpp, json.h - разработанная упрощенная бибилотека для работы с JSON<br>
 - json_builder.cpp, json_builder.h - необходимые классы/структуры для создания выходного фала в формате JSON<br>
 - json_reader.cpp, json_reader.h - необходимые классы/структуры для чтения и обработки входного фала в формате JSON<br>
 - log_duration.h - файл с классом, позволяющим производить **профилирование** <br>
 - map_renderer.cpp, map_renderer.h - код, отвечающий за визуализацию карты маршрутов в формате SVG.<br>
 - serialization.cpp, serialization.h - необходимые классы/структуры для обработки сериализованных фалов.<br>
 - svg.cpp, svg.h - обработки и хранения параметров изображения SVG<br>
 - transport_router.cpp, transport_router.h - построение маршрутов<br>
 - transport_catalogue.proto, transport_router.proto, svg.proto - proto файлы, для сериализации<br>


# Формат входных данных
Данные в формате JSON-объекта. Его верхнеуровневая структура:<br>

```
{
  "base_requests": [ ... ],
  "stat_requests": [ ... ]
} 
```
Это словарь, содержащий ключи:<br>
`base_requests` — массив с описанием автобусных маршрутов и остановок,<br>
`stat_requests` — массив с запросами к транспортному справочнику.<br>

## Описание базы маршрутов
Массив `base_requests` содержит элементы двух типов: маршруты и остановки. Они перечисляются в произвольном порядке.<br>

### Пример описания остановки:<br>

```
{
  "type": "Stop",
  "name": "Электросети",
  "latitude": 43.598701,
  "longitude": 39.730623,
  "road_distances": {
    "Улица Докучаева": 3000,
    "Улица Лизы Чайкиной": 4300
  }
} 
```
Описание остановки — словарь с ключами:<br>
 - type — строка, равная "Stop". Означает, что словарь описывает остановку;<br>
 - name — название остановки;<br>
 - latitude и longitude — широта и долгота остановки — числа с плавающей запятой;<br>
 - road_distances — словарь, задающий дорожное расстояние от этой остановки до соседних. Каждый ключ в этом словаре — название соседней остановки, значение — целочисленное расстояние в метрах.<br>
 
### Пример описания автобусного маршрута:
```
{
  "type": "Bus",
  "name": "14",
  "stops": [
    "Улица Лизы Чайкиной",
    "Электросети",
    "Улица Докучаева",
    "Улица Лизы Чайкиной"
  ],
  "is_roundtrip": true
} 
```

Описание автобусного маршрута — словарь с ключами:<br>
 - type — строка "Bus". Означает, что словарь описывает автобусный маршрут;<br>
 - name — название маршрута;<br>
 - stops — массив с названиями остановок, через которые проходит маршрут. У кольцевого маршрута название последней остановки дублирует название первой. Например: ["stop1", "stop2", "stop3", "stop1"];<br>
 - is_roundtrip — значение типа bool. true, если маршрут кольцевой.<br>

## Формат запросов к транспортному справочнику и ответов на них
Запросы хранятся в массиве `stat_requests`. В ответ на них программа должна вывести в stdout JSON-массив ответов:<br>

```
[
  { ответ на первый запрос },
  { ответ на второй запрос },
  ...
  { ответ на последний запрос }
] 
```
Каждый запрос — словарь с обязательными ключами `id` и `type`. Они задают уникальный числовой идентификатор запроса и его тип. В словаре могут быть и другие ключи, специфичные для конкретного типа запроса.<br>
В выходном JSON-массиве на каждый запрос `stat_requests` должен быть ответ в виде словаря с обязательным ключом `request_id`. Значение ключа должно быть равно `id` соответствующего запроса. В словаре возможны и другие ключи, специфичные для конкретного типа ответа.<br>
Порядок следования ответов на запросы в выходном массиве должен совпадать с порядком запросов в массиве `stat_requests`.<br>

### Получение информации о маршруте
Формат запроса:<br>

```
{
  "id": 12345678,
  "type": "Bus",
  "name": "14"
} 
```
Ключ type имеет значение “Bus”. По нему можно определить, что это запрос на получение информации о маршруте.
Ключ name задаёт название маршрута, для которого приложение должно вывести статистическую информацию.<br>
### Ответ на этот запрос должен быть дан в виде словаря:

```
{
  "curvature": 2.18604,
  "request_id": 12345678,
  "route_length": 9300,
  "stop_count": 4,
  "unique_stop_count": 3
} 
```
Ключи словаря:<br>
 - curvature — извилистость маршрута. Она равна отношению длины дорожного расстояния маршрута к длине географического расстояния. Число типа double;<br>
 - request_id — должен быть равен id соответствующего запроса Bus. Целое число;<br>
 - route_length — длина дорожного расстояния маршрута в метрах, целое число;<br>
 - stop_count — количество остановок на маршруте;<br>
 - unique_stop_count — количество уникальных остановок на маршруте.<br>
Например, на кольцевом маршруте с остановками A, B, C, A четыре остановки. Три из них уникальные.<br>
На некольцевом маршруте с остановками A, B и C пять остановок (A, B, C, B, A). Три из них уникальные.<br>
Если в справочнике нет маршрута с указанным названием, ответ будет таким:<br>

```
{
  "request_id": 12345678,
  "error_message": "not found"
} 
```
### Получение информации об остановке
Формат запроса:<br>

```
{
  "id": 12345,
  "type": "Stop",
  "name": "Улица Докучаева"
} 
```
Ключ name задаёт название остановки.<br>
### Ответ на запрос:

```
{
  "buses": [
      "14", "22к"
  ],
  "request_id": 12345
} 
```

Значение ключей ответа:
 - buses — массив названий маршрутов, которые проходят через эту остановку. Названия отсортированы в лексикографическом порядке.<br>
 - request_id — целое число, равное id соответствующего запроса Stop.<br>
Если в справочнике нет остановки с переданным названием, ответ на запрос должен быть такой:<br>

```
{
  "request_id": 12345,
  "error_message": "not found"
} 
```

## Структура словаря render_settings:
```
{
  "width": 1200.0,
  "height": 1200.0,

  "padding": 50.0,

  "line_width": 14.0,
  "stop_radius": 5.0,

  "bus_label_font_size": 20,
  "bus_label_offset": [7.0, 15.0],

  "stop_label_font_size": 20,
  "stop_label_offset": [7.0, -3.0],

  "underlayer_color": [255, 255, 255, 0.85],
  "underlayer_width": 3.0,

  "color_palette": [
    "green",
    [255, 160, 0],
    "red"
  ]
} 
```
 - width и height — ширина и высота изображения в пикселях. Вещественное число в диапазоне от 0 до 100000.<br>
 - padding — отступ краёв карты от границ SVG-документа. Вещественное число не меньше 0 и меньше min(width, height)/2.<br>
 - line_width — толщина линий, которыми рисуются автобусные маршруты. Вещественное число в диапазоне от 0 до 100000.<br>
 - stop_radius — радиус окружностей, которыми обозначаются остановки. Вещественное число в диапазоне от 0 до 100000.<br>
 - bus_label_font_size — размер текста, которым написаны названия автобусных маршрутов. Целое число в диапазоне от 0 до 100000.<br>
 - bus_label_offset — смещение надписи с названием маршрута относительно координат конечной остановки на карте. Массив из двух элементов типа double. Задаёт значения свойств dx и dy SVG-элемента <text>. Элементы массива — числа в диапазоне от –100000 до 100000.<br>
 - stop_label_font_size — размер текста, которым отображаются названия остановок. Целое число в диапазоне от 0 до 100000.<br>
 - stop_label_offset — смещение названия остановки относительно её координат на карте. Массив из двух элементов типа double. Задаёт значения свойств dx и dy SVG-элемента <text>. Числа в диапазоне от –100000 до 100000.<br>
 - underlayer_color — цвет подложки под названиями остановок и маршрутов. Формат хранения цвета будет ниже.
underlayer_width — толщина подложки под названиями остановок и маршрутов. Задаёт значение атрибута stroke-width элемента <text>. Вещественное число в диапазоне от 0 до 100000.<br>
 - color_palette — цветовая палитра. Непустой массив.<br>
 <br>
Цвет можно указать в одном из следующих форматов:<br>
 - в виде строки, например, "red" или "black";<br>
 - в массиве из трёх целых чисел диапазона [0, 255]. Они определяют r, g и b компоненты цвета в формате svg::Rgb. Цвет [255, 16, 12] нужно вывести в SVG как rgb(255,16,12);<br>
 - в массиве из четырёх элементов: три целых числа в диапазоне от [0, 255] и одно вещественное число в диапазоне от [0.0, 1.0]. Они задают составляющие red, green, blue и opacity цвета формата svg::Rgba. Цвет, заданный как [255, 200, 23, 0.85], должен быть выведен в SVG как rgba(255,200,23,0.85).<br>


### В массиве stat_requests запрос на получение изображения имеет следующий вид:
```
{
  "type": "Map",
  "id": 11111
} 
```
### Ответ на этот запрос отдаётся в виде словаря с ключами request_id и map:

```
{
  "map": "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\">\n  <polyline points=\"100.817,170 30,30 100.817,170\" fill=\"none\" stroke=\"green\" stroke-width=\"14\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n  <text fill=\"rgba(255,255,255,0.85)\" stroke=\"rgba(255,255,255,0.85)\" stroke-width=\"3\" stroke-linecap=\"round\" stroke-linejoin=\"round\" x=\"100.817\" y=\"170\" dx=\"7\" dy=\"15\" font-size=\"20\" font-family=\"Verdana\" font-weight=\"bold\">114</text>\n  <text fill=\"green\" x=\"100.817\" y=\"170\" dx=\"7\" dy=\"15\" font-size=\"20\" font-family=\"Verdana\" font-weight=\"bold\">114</text>\n  <text fill=\"rgba(255,255,255,0.85)\" stroke=\"rgba(255,255,255,0.85)\" stroke-width=\"3\" stroke-linecap=\"round\" stroke-linejoin=\"round\" x=\"30\" y=\"30\" dx=\"7\" dy=\"15\" font-size=\"20\" font-family=\"Verdana\" font-weight=\"bold\">114</text>\n  <text fill=\"green\" x=\"30\" y=\"30\" dx=\"7\" dy=\"15\" font-size=\"20\" font-family=\"Verdana\" font-weight=\"bold\">114</text>\n  <circle cx=\"100.817\" cy=\"170\" r=\"5\" fill=\"white\"/>\n  <circle cx=\"30\" cy=\"30\" r=\"5\" fill=\"white\"/>\n  <text fill=\"rgba(255,255,255,0.85)\" stroke=\"rgba(255,255,255,0.85)\" stroke-width=\"3\" stroke-linecap=\"round\" stroke-linejoin=\"round\" x=\"100.817\" y=\"170\" dx=\"7\" dy=\"-3\" font-size=\"20\" font-family=\"Verdana\">Морской вокзал</text>\n  <text fill=\"black\" x=\"100.817\" y=\"170\" dx=\"7\" dy=\"-3\" font-size=\"20\" font-family=\"Verdana\">Морской вокзал</text>\n  <text fill=\"rgba(255,255,255,0.85)\" stroke=\"rgba(255,255,255,0.85)\" stroke-width=\"3\" stroke-linecap=\"round\" stroke-linejoin=\"round\" x=\"30\" y=\"30\" dx=\"7\" dy=\"-3\" font-size=\"20\" font-family=\"Verdana\">Ривьерский мост</text>\n  <text fill=\"black\" x=\"30\" y=\"30\" dx=\"7\" dy=\"-3\" font-size=\"20\" font-family=\"Verdana\">Ривьерский мост</text>\n</svg>",
  "request_id": 11111
} 
```
Ключ map — строка с изображением карты в формате SVG. 
